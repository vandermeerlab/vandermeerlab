%% Script to create pooled data for sessions to be used for significance testing

% setup
clear;
%load significant cells
slist = {'R117-2007-06-01_ft_spec.mat', ...
'R117-2007-06-02_ft_spec.mat', ...
'R117-2007-06-03_ft_spec.mat', ...
'R117-2007-06-04_ft_spec.mat', ...
'R117-2007-06-05_ft_spec.mat', ...
'R117-2007-06-06_ft_spec.mat', ...
'R117-2007-06-07_ft_spec.mat', ...
'R117-2007-06-08_ft_spec.mat', ...
'R117-2007-06-09_ft_spec.mat', ...
'R117-2007-06-10_ft_spec.mat', ...
'R117-2007-06-11_ft_spec.mat', ...
'R117-2007-06-12_ft_spec.mat', ...
'R117-2007-06-13_ft_spec.mat', ...
'R117-2007-06-14_ft_spec.mat', ...
'R117-2007-06-15_ft_spec.mat', ...
'R117-2007-06-16_ft_spec.mat', ...
'R117-2007-06-17_ft_spec.mat', ...
'R117-2007-06-18_ft_spec.mat', ...
'R117-2007-06-19_ft_spec.mat', ...
'R117-2007-06-20_ft_spec.mat', ...
'R117-2007-06-21_ft_spec.mat', ...
'R119-2007-06-23_ft_spec.mat', ...
'R119-2007-06-24_ft_spec.mat', ...
'R119-2007-06-25_ft_spec.mat', ...
'R119-2007-06-26_ft_spec.mat', ...
'R119-2007-06-27_ft_spec.mat', ...
'R119-2007-06-28_ft_spec.mat', ...
'R119-2007-06-29_ft_spec.mat', ...
'R119-2007-06-30_ft_spec.mat', ...
'R119-2007-07-01_ft_spec.mat', ...
'R119-2007-07-03_ft_spec.mat', ...
'R119-2007-07-04_ft_spec.mat', ...
'R119-2007-07-05_ft_spec.mat', ...
'R119-2007-07-06_ft_spec.mat', ...
'R119-2007-07-07_ft_spec.mat', ...
'R119-2007-07-08_ft_spec.mat', ...
'R119-2007-07-09_ft_spec.mat', ...
'R119-2007-07-10_ft_spec.mat', ...
'R119-2007-07-11_ft_spec.mat', ...
'R119-2007-07-12_ft_spec.mat', ...
'R119-2007-07-13_ft_spec.mat', ...
'R119-2007-07-14_ft_spec.mat', ...
'R131-2007-09-02_ft_spec.mat', ...
'R131-2007-09-03_ft_spec.mat', ...
'R131-2007-09-04_ft_spec.mat', ...
'R131-2007-09-05_ft_spec.mat', ...
'R131-2007-09-06_ft_spec.mat', ...
'R131-2007-09-07_ft_spec.mat', ...
'R131-2007-09-08_ft_spec.mat', ...
'R131-2007-09-09_ft_spec.mat', ...
'R131-2007-09-10_ft_spec.mat', ...
'R131-2007-09-11_ft_spec.mat', ...
'R131-2007-09-13_ft_spec.mat', ...
'R131-2007-09-14_ft_spec.mat', ...
'R131-2007-09-15_ft_spec.mat', ...
'R131-2007-09-16_ft_spec.mat', ...
'R131-2007-09-17_ft_spec.mat', ...
'R131-2007-09-18_ft_spec.mat', ...
'R131-2007-09-19_ft_spec.mat', ...
'R131-2007-09-20_ft_spec.mat', ...
'R131-2007-09-21_ft_spec.mat', ...
'R131-2007-09-22_ft_spec.mat', ...
'R132-2007-10-09_ft_spec.mat', ...
'R132-2007-10-10_ft_spec.mat', ...
'R132-2007-10-11_ft_spec.mat', ...
'R132-2007-10-12_ft_spec.mat', ...
'R132-2007-10-13_ft_spec.mat', ...
'R132-2007-10-16_ft_spec.mat', ...
'R132-2007-10-17_ft_spec.mat', ...
'R132-2007-10-18_ft_spec.mat', ...
'R132-2007-10-19_ft_spec.mat', ...
'R132-2007-10-20_ft_spec.mat', ...
'R132-2007-10-21_ft_spec.mat', ...
'R132-2007-10-22_ft_spec.mat', ...
'R132-2007-10-23_ft_spec.mat', ...
'R132-2007-10-24_ft_spec.mat', ...
'R132-2007-10-25_ft_spec.mat', ...
'R132-2007-10-26_ft_spec.mat', ...
'R132-2007-10-27_ft_spec.mat', ...
'R132-2007-10-28_ft_spec.mat', ...
'R132-2007-10-29_ft_spec.mat'};

in_dir = 'D:\RandomVstrAnalysis\final_results\';
out_dir = 'D:\RandomVstrAnalysis\temp2\';
spk_dt = 0.025; % interspike interval for surrogate spike train used for spike-triggered spectrum pool

for iS = 1:length(slist)
    % Load File
    fn_in = strcat(in_dir, slist{iS});
    load(fn_in);
    f1 = extractBefore(slist{iS},'_');
    toks = strsplit(f1, '-');
    path = strcat('E:\ADRLabData\', toks{1}, '\', strjoin(toks(1:4),'-'));
    cd(path);

     % Load CSC, ExpKeys and the cell
    LoadExpKeys;
    if isfield(ExpKeys,'goodGamma_vStr')
        cfg = []; cfg.fc = ExpKeys.goodGamma_vStr;
    elseif isfield(ExpKeys, 'goodGamma')
        cfg = []; cfg.fc = ExpKeys.goodGamma;
    else
        error('Couldn''t find LFP field name.');
    end
    
    csc = LoadCSC(cfg); csc.data = csc.data-nanmean(csc.data); % could locdetrend to improve STA estimate
    % Note that Fieldtrip will interpoalate data to avoid gaps. Include
    % sanity tests to ensure STA/STS segments don't include these gaps.
    ft_csc = ft_read_neuralynx_interp(cfg.fc);
    
    % hacky code to separate out only ontrack-data
    temp_tvec = [0:length(ft_csc.time{1})-1];
    temp_offset = (double(ft_csc.hdr.LastTimeStamp)/1e6 - double(ft_csc.hdr.FirstTimeStamp)/1e6)/(length(temp_tvec) - 1);
    temp_tvec = temp_tvec * temp_offset;
     
    % Modify ft_csc
    ft_csc.time{1} = temp_tvec;
    ft_csc.fsample = 1/temp_offset;
    
    % Ensure that the new data doesn't have any Nans in it
    temp_tvec = temp_tvec + double(ft_csc.hdr.FirstTimeStamp)/1e6;
    temp_start = nearest_idx3(ExpKeys.TimeOnTrack, temp_tvec);
    temp_end = nearest_idx3(ExpKeys.TimeOffTrack, temp_tvec);
    cfg_onTrack.begsample = temp_start;
    cfg_onTrack.endsample = temp_end;
    
    cfg = [];
    sd.S = LoadSpikes(cfg);
    % Restrict spikes to only OnTrack
    sd.S = restrict(sd.S, iv(ExpKeys.TimeOnTrack, ExpKeys.TimeOffTrack));
    % Read the spike files into field trip format
    sd.S.ft_spikes = ft_read_spike(sd.S.label{1});
    
    cfg_f.begsample = cfg_onTrack.begsample;
    cfg_f.endsample = cfg_onTrack.endsample;
    f_spike = sd.S.ft_spikes;
    f_spike.timestamp{1} = double(ft_csc.hdr.FirstTimeStamp) +  ...
        10^6*(ft_csc.time{1}(1):spk_dt:ft_csc.time{1}(end));
    f_data = ft_appendspike([], ft_csc,f_spike);
    f_data = ft_redefinetrial(cfg_f,f_data);
    fprintf("Number of fake spikes for session %s is %d\n", path, sum(f_data.trial{1}(2,:)));
    cfg_f = [];
    cfg_f.method = 'mtmconvol';
    cfg_f.foi = 1:1:100;
    cfg_f.t_ftimwin = 5./cfg_f.foi;
    cfg_f.taper = 'hanning';
    cfg_f.spikechannel =  f_spike.label{1};
    cfg_sts.channel = f_data.label{1};
    od.pool_sts = ft_spiketriggeredspectrum(cfg_f, f_data);
    
    fn_out = strcat(out_dir, slist{iS});
    save(fn_out,'od');
    clear f_data cfg_f f_spike pool_sts
    
    % hard-coding number of frequencies (91) because it is known beforehand
%     shuf_sts = zeros(nshufs, 91);
%     shuf_ppc = zeros(nshufs, 91);
%     for iShuf = 1:nshufs
%         pool_count = length(pool_sts.time{1});
%         keep = randperm(pool_count);
%         keep = keep(1:od.spk_count);
%         this_shuf = pool_sts;
%         this_shuf.label{1} = label; % Because the pooled STS might have a differnt spike channel label
%         this_shuf.fourierspctrm{1} = pool_sts.fourierspctrm{1}(keep,:,:);
%         this_shuf.time{1} = pool_sts.time{1}(keep,:);
%         this_shuf.trial{1} = pool_sts.trial{1}(keep,:);
%         shuf_sts(iShuf,:) = nanmean(sq(abs(this_shuf.fourierspctrm{1})));
%         this_shuf_ppc = ft_spiketriggeredspectrum_stat(cfg_ppc, this_shuf);
%         shuf_ppc(iShuf,:) = this_shuf_ppc.ppc0;
%     end
%     od.shuf_sts = shuf_sts;
%     od.shuf_ppc = shuf_ppc;


    
end